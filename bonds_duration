#include <cmath>
#include <vector>
#include <iostream>
#include <string>
using namespace std;

class LP{
    public:
    
        const double ERROR = -1e30;
    
        vector<double> cash_flows;
        vector<double> times;
        double r;
    
        LP(); 
    
        double PV( 
                vector<double> cash_amounts,
                vector<double> cash_times,
                double r);
                
        double IRR(
                vector<double> cash_amounts,
                vector<double> cash_times);
                
        double PV_continuous(
                 vector<double> cash_amounts,
                 vector<double> cash_times,
                 double r);
                 
        double bond_pricing(
                vector<double> cash_amounts,
                vector<double> cash_times,
                double r);
        double bond_YTM(
                vector<double> cash_amounts,
                vector<double> cash_times,
                double bondprice);
                
        double bond_duration(
                    vector<double> cash_amounts,
                    vector<double> cash_times,
                    double r);
};

LP :: LP(){
    
    cash_flows.push_back(10.0);
    cash_flows.push_back(10.0);
    cash_flows.push_back(110.0);
    
    times.push_back(1.0);
    times.push_back(2.0);
    times.push_back(3.0);
    
    r = .09;
    
}
    


double LP ::  PV(       vector<double> cash_amounts,
                        vector<double> cash_times,
                        double r){
                    
    double PV = 0.0;
    
    for(int t = 0;t<cash_times.size(); t++){
        
        PV += cash_amounts[t]/pow((1.0+r),cash_times[t]);
    }
    return PV; 
}
    
double LP:: PV_continuous(
                            vector<double> cash_amounts,
                            vector<double> cash_times,
                            double r)
    { 
        double PV = 0.0;
        for( int t = 0; t<cash_times.size();t++){
            PV +=cash_amounts[t] * exp(-r*cash_times[t]);
        }
        return PV;
    }
    
double LP :: IRR(
                        vector<double> cash_amounts,
                        vector<double> cash_times){ 
                            
                            
    if(cash_times.size()!=cash_amounts.size()) return ERROR;
    const double ACCURACY = 1.0e-5;
    const int MAX_ITERATIONS = 50;
    
    double x1 = 0.0;
    double x2 = 0.2; 
    
    double f1 = PV(cash_flows,times,x1);
    double f2 = PV(cash_flows,times,x2);
    
    int i; 
    
    for(i=0;i<MAX_ITERATIONS;i++){
        if((f1*f2)<0.0){break;}
        if(fabs(f1)<fabs(f2)) { 
            f1 = PV(cash_flows,times,x1+=1.6*(x1-x2));
        }
        else{
            f2 = PV(cash_flows,times,x2 +=1.6*(x2-x1));
        };
    };
    
    
    if(f2*f1>0.0){return ERROR;};
    
    double f = PV(cash_flows,times,x1);
    double rtb;
    double dx = 0.0;
    
    if(f<0.0){
        rtb = x1;
        dx = x2-x1;
    }
    else { 
        rtb = x2;
        dx = x1-x2; 
    };
    
    for(i = 0; i<MAX_ITERATIONS;i++){
        dx *= .5; 
        double x_mid = rtb+dx;
        double f_mid = PV(cash_flows,times,x_mid);
        if(f_mid<=0.0) rtb = x_mid;
        if((fabs(f_mid)<ACCURACY || (fabs(dx)<ACCURACY))) return x_mid;
    };
}
    
double LP :: bond_pricing (
                            vector<double> cash_amounts,
                            vector<double> cash_times,
                            double r) 
    {
        double p = 0;
        for( int i = 0; i<cash_times.size();i++){
            
            p +=cash_amounts[i]/pow((1+r),times[i]);
        }
        return p;
    }
                              
                                
double LP :: bond_YTM (
                        vector<double> cash_amounts,
                        vector<double> cash_times,
                        double bondprice) 
    {
        const double ACCURACY = 1e-5; 
        const int MAX_ITERATIONS = 200; 
        double bot = 0, top =1.0; 
        
        while(bond_pricing(cash_amounts,cash_times,top)>bondprice){top = top*2;};
        
        double r = 0.5*(top+bot);
        for(int i=0;i<MAX_ITERATIONS;i++){
            double diff  = bond_pricing(cash_amounts,cash_times,r) - bondprice;
            if(fabs(diff)<ACCURACY){ return r;};
            
            if(diff>0.0) {bot = r;}
            else {top =r;};
            r = 0.5*(top+bot);
        };
        return r; 
    };
    
    
double LP :: bond_duration( vector<double> cash_amounts,
                            vector<double> cash_times,
                            double r)
                            
    { 
        double B = 0;
        double D = 0; 
        for(int i = 0;i<cash_times.size();i++){
            D +=cash_times[i] * cash_amounts[i]/pow(1+r,cash_times[i]);
            B += cash_amounts[i]/pow(1+r,cash_times[i]);
        };
        return D/B;
    };
            
            
        
        
        
    
int main()
{   
    LP investment; 
    /*
    double presentvalue = investment.PV(investment.cash_flows,investment.times,investment.r);
    cout<<presentvalue;
    
    double irr; 
    irr  = investment.IRR(investment.cash_flows,investment.times);
    cout<<"\n"<<irr;
    */
    
    double B = investment.bond_pricing(investment.cash_flows,investment.times,investment.r);
    cout<<B<<"\n"; 
    
    
    double C; 
    C = investment.bond_YTM(investment.cash_flows,investment.times,B);
    cout<<C;
    cout<< "\n";
    double D; 
    D = investment.bond_duration(investment.cash_flows,investment.times,investment.r);
    cout<<D; 
    
    
    return 0;
}
